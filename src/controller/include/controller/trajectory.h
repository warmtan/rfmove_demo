//
// Created by yongxi on 2021/7/6.
//

#ifndef MOVEIT_NO_ROS_TRAJECTORY_H
#define MOVEIT_NO_ROS_TRAJECTORY_H

#include <trajectory_interface/quintic_spline_segment.h>
#include <moveit/robot_trajectory/robot_trajectory.h>
#include <joint_trajectory_controller/joint_trajectory_segment.h>
#include <trajectory_interface/pos_vel_acc_state.h>
#include <Eigen/Geometry>

/**
 * Trajectory representation using trajectory_interface::QuinticSplineSegment.
 * @details SplineTrajectory can be constructed from robot_trajectory::RobotTrajectory which represents the trajectory
 * for one JointModelGroup.
 */
class SplineTrajectory {
public:
    typedef joint_trajectory_controller::JointTrajectorySegment<trajectory_interface::QuinticSplineSegment<double>> Segment;
    typedef std::vector<Segment> TrajectoryPerJoint;
    typedef std::vector<TrajectoryPerJoint> Trajectory;

    /// Time stamps parameterization type
    enum class Parameterization{
        SPLINE, ///< IterativeSplineParameterization
        TIME,   ///< IterativeParabolicTimeParameterization
    };
    explicit SplineTrajectory(robot_trajectory::RobotTrajectoryPtr robot_trajectory,
                     bool computeTimeStamps = true,
                     Parameterization param = Parameterization::SPLINE);
    /**
     * Sample positions, velocity and acceleration with a fix interval.
     * @param joint_name
     * @param sample Sample result would be pushed backed into sample.
     * @param interval The time interval between samples.
     * @return The number of data points sampled.
     */
    int sample_by_interval(const std::string& joint_name, trajectory_interface::PosVelAccState<double>& sample, double interval = 1e-3);

    int sample_at_time(trajectory_interface::PosVelAccState<double>& result, double time_point);

    /**
     * The intex of specific joint.
     * @details This is also the order of sample result.
     * @param joint_name
     * @return return -1 if not exists.
     */
    int jointIndex(const std::string& joint_name);

    /**
     * Total time duration of trajectory.
     * @details It is computed by 'last_waypoint.endtime - first_waypoint.starttime'
     * @return Time duration. Return 0 if the trajectory is empty.
     */
    double duration();

    /**
     * Start time of trajectory.
     * @details It should be 0 as we only use relative time.
     * @return
     */
    double startTime();

    /**
     * End time of trajectory
     * @return
     */
    double endTime();

    /**
     * Compute the time stamps together with velocity and acceleration for specific RobotTrajectory.
     * @details RobotTrajectory has no time info when generated by motion planner. Moveit propose post-processing
     * method to compute the time info for RobotTrajectory.
     * @param trajectory
     * @param param
     */
    static void computeTimeStamps(robot_trajectory::RobotTrajectoryPtr trajectory, Parameterization param = Parameterization::SPLINE);

    /**
     * Get the transform of trajectory tip according to robot base frame.
     * @details One robot may have multi tip links. However, here we only fetch the first tip link corresponding
     * to JointModelGroup of this trajectory.
     * @param result The result affine matrices would be put into result.
     * @return Number of matrices returned. It should be the same as the number of robot trajectory waypoints.
     */
    int getTipTransforms(std::vector<Eigen::Affine3d>& result);

    /**
     * @return Name of joint model group for this trajectory.
     */
    const std::string& getGroupName();

    const std::vector<std::string>& getJointNames();

private:

    std::vector<std::string> joint_names_;
    std::string group_name_;
    std::vector<std::string> tip_names_;    // Name of tip effector
                                            // Size is 1 in most cases
    const moveit::core::LinkModel* tip_link_;     // Tip link model
    robot_trajectory::RobotTrajectoryPtr robot_trajectory_;
    moveit_msgs::RobotTrajectory robot_trajectory_msg_;
    Trajectory trajectory_;
};

typedef std::shared_ptr<SplineTrajectory> SplineTrajectoryPtr;

#endif //MOVEIT_NO_ROS_TRAJECTORY_H
